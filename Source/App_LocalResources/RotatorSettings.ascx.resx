<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="btnCancel.Text" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="btnSubmit.Text" xml:space="preserve">
    <value>Submit</value>
  </data>
  <data name="lblAnimationDuration.Help" xml:space="preserve">
    <value>Choose how many seconds the fading animation will last.  You can use decimals to choose to last a fraction of a second.</value>
  </data>
  <data name="lblAnimationDuration.Text" xml:space="preserve">
    <value>Animation Duration: </value>
  </data>
  <data name="lblPauseOnMouseOver.Help" xml:space="preserve">
    <value>Pause the rotation of content when the user's mouse is over the content area.</value>
  </data>
  <data name="lblPauseOnMouseOver.Text" xml:space="preserve">
    <value>Pause on MouseOver: </value>
  </data>
  <data name="lblRotatorDelay.Help" xml:space="preserve">
    <value>The number of seconds each item is shown before the next item appears.</value>
  </data>
  <data name="lblRotatorDelay.Text" xml:space="preserve">
    <value>Rotator Delay: </value>
  </data>
  <data name="lblRotatorHeight.Help" xml:space="preserve">
    <value>Use this setting to force the area for the rotating content to be a specific height, measured in pixels.</value>
  </data>
  <data name="lblRotatorHeight.Text" xml:space="preserve">
    <value>Rotator Height: </value>
  </data>
  <data name="lblRotatorWidth.Text" xml:space="preserve">
    <value>Rotator Width: </value>
  </data>
  <data name="lblUseAnimations.Help" xml:space="preserve">
    <value>Choose whether to use fading animations when the content item changes.</value>
  </data>
  <data name="lblUseAnimations.Text" xml:space="preserve">
    <value>Use Animations: </value>
  </data>
  <data name="pixels.Text" xml:space="preserve">
    <value>pixels</value>
  </data>
  <data name="seconds.Text" xml:space="preserve">
    <value>seconds</value>
  </data>
  <data name="lblRotationHeader.Text" xml:space="preserve">
    <value>Rotation Settings&lt;hr/&gt;</value>
  </data>
  <data name="rfvAnimationDuration.Text" xml:space="preserve">
    <value>Animation Duration is required</value>
  </data>
  <data name="rfvRotatorDelay.Text" xml:space="preserve">
    <value>Rotator Delay is required</value>
  </data>
  <data name="valAnimationDuration.Text" xml:space="preserve">
    <value>Animation Duration must be a number</value>
  </data>
  <data name="valContentHeight.Text" xml:space="preserve">
    <value>Content Height must be an integer</value>
  </data>
  <data name="valContentWidth.Text" xml:space="preserve">
    <value>Content Width must be an integer</value>
  </data>
  <data name="valRotatorDelay.Text" xml:space="preserve">
    <value>Rotator Display must be an integer</value>
  </data>
  <data name="valRotatorHeight.Text" xml:space="preserve">
    <value>Rotator Height must be an integer</value>
  </data>
  <data name="valRotatorWidth.Text" xml:space="preserve">
    <value>Rotator Width must be an integer</value>
  </data>
  <data name="Content.Header" xml:space="preserve">
    <value>Content</value>
  </data>
  <data name="None.Text" xml:space="preserve">
    <value>None</value>
  </data>
  <data name="Rotation.Header" xml:space="preserve">
    <value>Rotation</value>
  </data>
  <data name="ControlTitle_modsettings.Text" xml:space="preserve">
    <value>Rotator Settings</value>
  </data>
  <data name="AutoStopBegin.Text" xml:space="preserve">
    <value>Automatically stop rotation after </value>
  </data>
  <data name="AutoStopEnd.Text" xml:space="preserve">
    <value> items are displayed</value>
  </data>
  <data name="lblAutoStop.Help" xml:space="preserve">
    <value>Choose whether to automatically stop the rotation after a specific number of items are displayed</value>
  </data>
  <data name="lblAutoStop.Text" xml:space="preserve">
    <value>Auto Stop</value>
  </data>
  <data name="rfvAutoStopCount.Text" xml:space="preserve">
    <value>Number of items before auto stop is required when checked</value>
  </data>
  <data name="valAutoStopCount.Text" xml:space="preserve">
    <value>Number of items before auto stop must be an integer</value>
  </data>
  <data name="Advanced.Header" xml:space="preserve">
    <value>Advanced</value>
  </data>
  <data name="lblAdvancedHeader.Text" xml:space="preserve">
    <value>Advanced Settings&lt;hr/&gt;</value>
  </data>
  <data name="lblContainerResize.Help" xml:space="preserve">
    <value>Check to automatically resize the container to fit the largest content item</value>
  </data>
  <data name="lblContainerResize.Text" xml:space="preserve">
    <value>Auto Resize Container</value>
  </data>
  <data name="lblContinuous.Help" xml:space="preserve">
    <value>Check to make rotation to occur continuously, i.e. the next transition should start as soon as the current transition ends.</value>
  </data>
  <data name="lblContinuous.Text" xml:space="preserve">
    <value>Continuous Rotation</value>
  </data>
  <data name="lblContentHeader.Text" xml:space="preserve">
    <value>Content Settings&lt;hr/&gt;</value>
  </data>
  <data name="lblInitialDelay.Help" xml:space="preserve">
    <value>Choose the additional delay for the first transition.  This number can also be negative to have the initial item transition more quickly than the rest.</value>
  </data>
  <data name="lblInitialDelay.Text" xml:space="preserve">
    <value>Additional Initial Delay</value>
  </data>
  <data name="valInitialDelay.Text" xml:space="preserve">
    <value>Additional Initial Delay must be a number</value>
  </data>
  <data name="InitialDelayBegin.Text" xml:space="preserve">
    <value>Delay first content item an additional </value>
  </data>
  <data name="lblManuallyTriggeredTransitionSpeed.Help" xml:space="preserve">
    <value>Choose whether you would like "triggered" transitions (transitions caused by a pager or the previous or next buttons) to occur with a different speed than the automatic transitions.</value>
  </data>
  <data name="lblManuallyTriggeredTransitionSpeed.Text" xml:space="preserve">
    <value>Triggered Transition Speed</value>
  </data>
  <data name="Loading.Alt" xml:space="preserve">
    <value>Loading...</value>
  </data>
  <data name="ManuallyTriggeredTransitionSpeedBegin.Text" xml:space="preserve">
    <value>User triggered transitions should last </value>
  </data>
  <data name="rfvInitialDelay.Text" xml:space="preserve">
    <value>Additional Initial Delay is required when checked</value>
  </data>
  <data name="rfvManuallyTriggeredTransitionSpeed.Text" xml:space="preserve">
    <value>Triggered Transition Speed is required when checked</value>
  </data>
  <data name="valManuallyTriggeredTransitionSpeed.Text" xml:space="preserve">
    <value>Triggered Transition Speed must be a number</value>
  </data>
  <data name="lblLoop.Help" xml:space="preserve">
    <value>Choose whether to continue the rotation indefinitely, or to just display each item once</value>
  </data>
  <data name="lblLoop.Text" xml:space="preserve">
    <value>Loop</value>
  </data>
  <data name="lblRandomOrder.Help" xml:space="preserve">
    <value>Choose whether the display content items in a random order.  Otherwise items are sorted first by the items' Sort Order field, then their Start Date, and finally, if those two fields are the same, by their Title</value>
  </data>
  <data name="lblRandomOrder.Text" xml:space="preserve">
    <value>Random Order</value>
  </data>
  <data name="lblSimultaneousTransitions.Help" xml:space="preserve">
    <value>Choose whether the current content item's "out" transitions should happen at the same time as the next content item's "in" transition</value>
  </data>
  <data name="lblSimultaneousTransitions.Text" xml:space="preserve">
    <value>Simultaneous Transitions</value>
  </data>
  <data name="blindX.Text" xml:space="preserve">
    <value>Blinds X</value>
  </data>
  <data name="blindY.Text" xml:space="preserve">
    <value>Blinds Y</value>
  </data>
  <data name="blindZ.Text" xml:space="preserve">
    <value>Blinds Z</value>
  </data>
  <data name="cover.Text" xml:space="preserve">
    <value>Cover</value>
  </data>
  <data name="curtainX.Text" xml:space="preserve">
    <value>Curtain X</value>
  </data>
  <data name="curtainY.Text" xml:space="preserve">
    <value>Curtain Y</value>
  </data>
  <data name="fade.Text" xml:space="preserve">
    <value>Fade</value>
  </data>
  <data name="fadeZoom.Text" xml:space="preserve">
    <value>Zoom &amp; Fade</value>
  </data>
  <data name="growX.Text" xml:space="preserve">
    <value>Grow X</value>
  </data>
  <data name="growY.Text" xml:space="preserve">
    <value>Grow Y</value>
  </data>
  <data name="lblAnimationEffect.Help" xml:space="preserve">
    <value>Choose one or more effects to use when transitioning items.</value>
  </data>
  <data name="lblAnimationEffect.Text" xml:space="preserve">
    <value>Animation Effect(s)</value>
  </data>
  <data name="lblForceSlidesToFitContainer.Help" xml:space="preserve">
    <value>Choose whether the slides should be stretched to fit exactly within the container</value>
  </data>
  <data name="lblForceSlidesToFitContainer.Text" xml:space="preserve">
    <value>Force Slides to Fit Within Container</value>
  </data>
  <data name="rfvAnimationEffect.Text" xml:space="preserve">
    <value>At least one Animation Effect is required</value>
  </data>
  <data name="scrollDown.Text" xml:space="preserve">
    <value>Scroll Down</value>
  </data>
  <data name="scrollHorz.Text" xml:space="preserve">
    <value>Scroll Horizontal</value>
  </data>
  <data name="scrollLeft.Text" xml:space="preserve">
    <value>Scroll Left</value>
  </data>
  <data name="scrollRight.Text" xml:space="preserve">
    <value>Scroll Right</value>
  </data>
  <data name="scrollUp.Text" xml:space="preserve">
    <value>Scroll Up</value>
  </data>
  <data name="scrollVert.Text" xml:space="preserve">
    <value>Scroll Vertical</value>
  </data>
  <data name="shuffle.Text" xml:space="preserve">
    <value>Shuffle</value>
  </data>
  <data name="slideX.Text" xml:space="preserve">
    <value>Slide X</value>
  </data>
  <data name="slideY.Text" xml:space="preserve">
    <value>Slide Y</value>
  </data>
  <data name="slideZ.Text" xml:space="preserve">
    <value>Slide Z</value>
  </data>
  <data name="toss.Text" xml:space="preserve">
    <value>Toss</value>
  </data>
  <data name="turnDown.Text" xml:space="preserve">
    <value>Turn Down</value>
  </data>
  <data name="turnLeft.Text" xml:space="preserve">
    <value>Turn Left</value>
  </data>
  <data name="turnRight.Text" xml:space="preserve">
    <value>Turn Right</value>
  </data>
  <data name="turnUp.Text" xml:space="preserve">
    <value>Turn Up</value>
  </data>
  <data name="uncover.Text" xml:space="preserve">
    <value>Uncover</value>
  </data>
  <data name="wipe.Text" xml:space="preserve">
    <value>Wipe</value>
  </data>
  <data name="zoom.Text" xml:space="preserve">
    <value>Zoom</value>
  </data>
  <data name="lblRotatorWidth.Help" xml:space="preserve">
    <value>Use this setting to force the area for the rotating content to be a specific width, measured in pixels.</value>
  </data>
</root>